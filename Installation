# What’s Actually Needed for CDOCKER:

## Core (required to build & run CDOCKER from CHARMM scripts)

* **CHARMM** source (with **C36** force fields) and a standard build toolchain:

  * `gcc`, `gfortran`, `make`, `binutils` (and `cmake` if your toolchain expects it)
* (If you want the **pyCHARMM** interface) a **Python 3.x** environment to install `pyCHARMM`
  *Notes:* Docking itself runs in CHARMM; pyCHARMM is an optional Python wrapper/workflow layer.

---

## Strongly Recommended (to replicate the paper’s workflow & performance)

* **OpenMM** (so CHARMM can use the **CHARMM/OpenMM parallel simulated annealing** during docking)
* **RDKit** (for **ligand conformer generation**; the paper generated *N* conformers per ligand using EDKTG)
* **CGenFF / ParamChem** (for **ligand topology/parameters**; not a conda package—use the server or local tools)
* **MMTSB ToolSet** (for **pose clustering** like in the paper’s analysis)

> Additional notes aligned with the paper:
>
> * Docking ran in **CHARMM** with **CHARMM/OpenMM** parallel simulated annealing; **C36** force fields were used.
> * **RDKit** handled conformer generation; **ParamChem (CGenFF)** provided ligand parameters; **MMTSB** performed clustering.
> * Optional **FACTS** rescoring is **inside CHARMM** (no extra conda deps).

---

## Optional / Not Required by CDOCKER (safe to prune)

* **MPI stack**: `openmpi`, `mpi4py` — not used in the paper’s CDOCKER workflow.
* **FFTW / FFTDOCK / BLaDE** flags — not needed for **Rigid CDOCKER** per se (FFTDOCK and BLaDE are different CHARMM features).
* Jupyter stack (`jupyter*`), visualization/analysis libs (`py3dmol`, `pymol-open-source`, `mdtraj`, `biopython`, `pandas`) — great for notebooks/figures, but **not** required to run CDOCKER.
* **MOE** — the paper used MOE for protonation; it’s commercial and **not required** to run CDOCKER. Use your preferred pKa/protonation workflow.

---

## Minimal Conda Install (paper-faithful but lean)

```bash
# 1) create & activate env (use Python only if you’ll use pyCHARMM)
conda create -y -n cdocker_env python=3.9
conda activate cdocker_env

# 2) core toolchain for building CHARMM
conda install -y -c conda-forge gcc gfortran make binutils

# 3) strongly recommended to match paper’s workflow/perf
#    - OpenMM: enables CHARMM/OpenMM parallel SA during docking
#    - RDKit:   ligand conformer generation
conda install -y -c conda-forge openmm rdkit
```

> You’ll still obtain **CHARMM** (academic) and **CGenFF/ParamChem** externally, and install **MMTSB ToolSet** separately (only if you want the same clustering step as the paper).

---

## Minimal YAML (drop-in)

```yaml
name: cdocker_env
channels:
  - conda-forge
dependencies:
  - python=3.9        # only if using pyCHARMM; otherwise omit Python entirely
  - gcc
  - gfortran
  - make
  - binutils
  - openmm            # recommended (paper used CHARMM/OpenMM parallel SA)
  - rdkit             # recommended (paper generated N conformers per ligand)
```

---

## Build Guidance (what to trim from your configure flags)

* For a **minimal CPU build** of CHARMM with CDOCKER, you **don’t** need `--with-fftdock`, BLaDE, or MPI flags.
* If you want to **match the paper’s runtime behavior**, compile CHARMM **with OpenMM support** and use the **CHARMM/OpenMM** simulated annealing path during docking.
